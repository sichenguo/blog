### 前言

我在最近的工作中开始使用 Vue 进行开发，但是我在上一家公司积累了三年以上 React 开发经验。虽然在两种不同的前端框架之间进行切换确实需要学习很多，但是二者之间在很多基础概念、设计思路上是相通的。其中之一就是组件设计，包括组件层次结构设计以及组件各自的职责划分。

组件是大多数现代前端框架的基本概念之一，在 React 和 Vue 以及 Ember 和 Mithril 等框架中均有所体现。组件通常是由一串标记语言组成的集合，通常还包含一些逻辑和样式。它们被创建的目的就是作为可复用的模块去构建我们的应用程序。

类似于传统 OOP 语言中 class 的设计，在设计组件的时候需要考虑到很多方面，以便它们可以  很好的复用，组合，分离和低耦合，但是功能可以比较稳定的实现，即使是在  超出实际测试用例范围的情况下。这样的设计说起来容易做起来却很难，因为现实中我们往往没有足够的时间按照最优的方式去做。

### 方法

在本文中，我想介绍一些组件相关的设计概念，在进行前端开发时应该考虑  这些概念。我认为最好的方法是给每个概念一个简洁精炼的名字， 然后逐一解释每个概念是什么以及为什么重要，对于比较抽象概念的会举一些例子来帮助理解。

以下这个列表并不是不全面也不完整，但我注意到的只有 8 件事情值得一提，对于那些已经可以编写基本组件但想要提高他们的技术设计技能的人来说。所以这是列表：
以下列举的这个  列表仅仅是是我注意到的 8 个方面， 当然组件设计还有其他一些方面。在此我只是列举出来我认为值得一提的。

对于已经掌握基本的组件设计并且想要提高自身的组件设计能力的开发者， 我认为以下 8  项是我认为值得去注意的，当然这并不是组件设计的全部。

1. 层次结构和 UML 类图
2. 扁平化、面向数据的 state/props
3. State change purity
4. 低耦合
5. 抽离辅助代码
6. View distillation
7. 及时模块化
8. Centralised state considerations

请注意，代码示例可能有一些小问题或有点人为设计。但是它们并不复杂，只是想通过这些例子来帮助更好的理解概念。

### 层次结构和类图

应用内的组件共同形成树结构， 而在设计过程中将组件树可视化展示可以帮助你全面了解应用程序的布局。一个比较好的展示这些的办法就是组件图。

UML 中有一个在 OOP 类设计中经常使用的类型，称为 UML 类图。类图中显示了类属性、方法、访问修饰符、类与其他类的关系等。虽然 OOP 类设计和前端组件设计差异很大，但是通过图解辅助设计的方法值得参考。对于前端组件，该图表可以显示：

- State
- Props
- Methods
- 与其他组件的关系（ Relationship to other components ）

因此，让我们看一下下面这个基础表组件的组件层次图，该组件的渲染对象是一个数组。该组件的功能包括显示总行数、标题行和一些数据行，以及在单击其单元格标题格时对该列进行排序。在它的 props 中，它将传递列列表（具有属性名称和该属性的人类可读版本），然后传递数据数组。我们可以添加一个可选的'on row click'功能来进行测试。

![img](https://cdn-images-1.medium.com/max/1600/0*BpUkUiLupqoBO3ux)

虽然这样的事情可能看起来有点多，但是它具有许多优点，并且在大型应用程序开发设计中所需要的。这样会带来的一个比较重要的问题是它会需要你在开始 codeing 之前就需要考虑到具体细节的实现，例如每个组件需要什么类型的数据，需要实现哪些方法，所需的状态属性等等。

一旦你对如何构建一个组件（或一组组件）的整体有大概的思路，就会很容易认为当自己真正开始编码实现时，它会如自己所期望的按部就班的完成，但事实上往往会出现一些预料之外的事情， 当然你肯定不希望会因此去重构之前的某些部分，或者忍受初始设想中的缺点并因此扰乱你的代码思路。而这些类图的以下优点可以帮助你有效的规避以上问题，优点如下：

1. 一个易于理解的组件组成和关联视图
2. 一个易于理解的应用程序 UI 层次结构的概述
3. 一个结构数据层次及其流动方式的视图
4. 一个组件功能职责的快照
5. 便于使用图表软件创建

顺带一提，上图并不是基于某些官方标准，比如 UML 类图，它是我基本上创建的一套表达规则。例如，在 props 、方法的参数和返回值的数据类型定义声明都是基于 Typescript 语法。我还没有找到书写前端组件类图的官方标准，可能是由于前端 Javascript 开发的相对较新且生态系统不够完善所致，但如果有人知道主流标准，请在回复中告诉我！

### 扁平的，面向数据的 state/props

在 state 和 props 频繁被 watch 和 update 的情况下，如果你有使用嵌套数据，那么你的性能可能会受到影响，尤其是在以下场景中，例如一些因为浅对于而触发的重新渲染；在涉及 immutability 的库中，比如 React，你必须创建状态的副本而不是像在 Vue 中那样直接更改它们，并且使用嵌套数据这样做可能会创建笨拙，丑陋的代码。

![img](https://cdn-images-1.medium.com/max/1600/0*mZkPIHnDUAJqnggm)

即使使用展开运算符，这种写法也并不够优雅。扁平 props 也可以很好地清除组件正在使用的数据值。如果你传给组件一个对象但是你并不能清楚的知道对象内部的属性值，所以找出**实际需要**的数据值是来自组件具体的属性值则是额外的工作。但如果 props 足够扁平化，那么起码会方便使用和维护。

![img](https://cdn-images-1.medium.com/max/1600/0*oWFoKOVdtDEiOt5t)

state / props 还应该只包含组件渲染所需的数据。You shouldn’t store entire components in the state/props and render straight from there.

（此外，对于数据繁重的应用程序，数据规范化可以带来巨大的好处，除了扁平化之外，你可能还需要考虑一些别的优化方法）。

### 更加纯粹的 State 变化

对 state 的更改通常应该响应某种事件，例如用户单击按钮或 API 的响应。此外它们不应该因为别的 state 的变化而做出响应，因为 state 之间这种关联可能会导致难以理解和维护的组件行为。state 变化应该没有副作用。

如果你滥用`watch`而不是将这个逻辑烘焙到任何事件处理程序处理状态变化的第一个位置，那么可以在 Vue 中看到这个问题。我们来看一个基本的 Vue 示例。我正在研究一个从 API 获取一些数据并将其呈现给表的组件，其中排序，过滤等功能都是后端完成的，因此前端需要做的就是 watch 所有搜索参数，并在其变化时触发 API 调用。其中一个需要 watch 的值是“zone”，这是一个过滤器。当更改时，我们想要使用过滤后的值重新获取服务端数据。watcher 如下：

![img](https://cdn-images-1.medium.com/max/1600/0*gmnqOd2JMQwEn0sm)

你会发现一些奇怪的东西。如果他们超出了结果的第一页，我们重置页码然后结束？这似乎不对,如果它们不在第一页上，我们应该重置分页并触发 API 调用，对吧？为什么我们只在第 1 页上重新获取数据？实际上原因是这样养，让我们来看下完整的 watch：

![img](https://cdn-images-1.medium.com/max/1600/0*93mIcG6EdFJUcAvb)

当分页改变时，应用首先会通过 pagination 的处理函数重新获取数据。因此，如果我们改变了分页，我们并不需要去关注数据更新这段逻辑。

让我们一下来考虑以下流程：如果当前页面超出了第 1 页并且更改了 zone，而这个变化会触发另一个状态（pagination）发生变化，进而触发 pagination 的观察者重新请求数据。这样并不是预料之中的行为，而且产生的代码也不够直观。

解决方案是改变页码这个行为的事件处理函数（不是观察者，用户更改页面的实际处理函数）应该更改页面值**并**触发 API 调用请求数据。这也将消除对观察者的需求。通过这样的设置，直接从其他地方改变分页状态也不会导致重新获取数据的副作用。

虽然这个例子**非常**简单，但不难看出将更复杂的状态更改关联在一起会产生令人难以理解的代码，这些代码不仅不可扩展并且是调试的噩梦。

### 松耦合

组件的核心思想是它们是可重用的，并且为此它们必须具有功能性和完整性。“耦合”是指实体彼此依赖的术语。松散耦合的实体应该能够独立运行，而不依赖于其他模块。就前端组件而言，耦合的主要部分是组件的功能依赖于其父级及其传递的props的多少，以及它呈现的子级（以及导入，如第三方模块或自定义脚本）。

紧密耦合的组件往往是更多的重用工作，当它们不是原始父组件的子项时，没有正常运行，有一个孩子或一系列只在其原始上下文中有意义的子项，并导致代码重复，因为它们被过度装配他们原来的用例。

在设计组件时，你应该尝试考虑一般用例，而不是最初要满足的特定用例。虽然某些组件显然只是出于特定目的，但没关系，如果在设计它们时以广泛的视角处理它们，那么很多组件将具有更广泛的适用性。

让我们看一个简单的 React 用例，你想在其中列出一个链接列表，用于浏览你的站点，并显示一个徽标。在这种情况下，我们将考虑从最初设计的上下文中解除绑定组件。这是最初的版本：

![img](https://cdn-images-1.medium.com/max/1600/0*YdWfhl9HILY99Di0)

虽然这可能会满足最初的预期用例，但它在任何情况下都不可重复使用，除了它的初始上下文。如果你想要拥有不同的链接，取决于他们是否是管理员，该怎么办？你必须复制粘贴它并更改路线。而且，假设你知道自己想要实现用户可以自定义链接的功能。你无法实际硬编码，因为可能存在各种组合。让我们制作一个更可重用的组件：

![img](https://cdn-images-1.medium.com/max/1600/0*SRwtEhiEfcFEneFa)

在这里我们可以看到，虽然它确实有原始链接和标识为默认值，我们可以在道具覆盖它们通过。因此，假设我们要为管理员使用创建特殊用例：

![img](https://cdn-images-1.medium.com/max/1600/0*bgK5B8oRXhMQJQWG)

无需新组件！如果需要，我们也可以动态构建链接数组，这解决了用户拥有自定义链接列表的用例。此外，虽然在这个具体的例子中没有解决，但我们仍然可以注意到这个组件没有绑定到任何特定的父或子。它可以在任何需要的地方呈现。现在，这个组件比原始环境更可重用。

假设它不提供高度特定的一次性用例，设计组件的最终目标是它与父组件松散耦合，呈现泛型和逻辑子元素，而不受其上下文的约束。起源。

### 辅助代码分离

这个可能不那么学术，但我仍然认为这很重要。与你的代码库进行物理交互是软件工程的一部分，有时一些基本的组织原则可以使事情变得更加顺畅。在数周内每天工作 8 小时的代码库时，小的改动可以产生很大的不同。一个这样的组织原则是将辅助代码分离到自己的文件中的想法，这样你在处理组件时就不必处理它。此类代码包括但不限于以下内容：

- 配置代码
- 虚拟数据
- 大量非技术文档

在尝试处理组件的核心代码时，不仅需要滚动这些内容而且会加剧偏见，这不仅麻烦而烦人。在处理组件时，你希望它们尽可能通用且可重用。查看与组件当前上下文相关的特定信息可能会使组件的使用难以超出其原始用例。

### 查看蒸馏

虽然它可能具有挑战性，但开发组件的一个好方法是使它们包含渲染它们所需的最小 Javascript。一些无关紧要的东西，比如数据提取，数据整理或事件处理逻辑，理想情况下应该是通用的，并移入外部脚本或升级为共同的祖先。

这将组件分解为它的“视图”部分，即你看到的内容（标记和样式）。其中的 Javascript 仅用于帮助渲染视图，*可能*还有一些特定于该组件的额外逻辑（即在其他地方使用）。除此之外的任何事情，例如 API 调用，值的非特定格式化（例如货币或时间）或跨组件重用的数据，可以移动到提升的外部脚本。让我们看一下 Vue 中的一个简单示例，使用嵌套列表组件。我们可以先查看有问题的版本。

这是第一级：

![img](https://cdn-images-1.medium.com/max/1600/0*P5gJwro7sZUhBr_7)

这是嵌套列表组件：

![img](https://cdn-images-1.medium.com/max/1600/0*9nsuVNekUXJ24FEN)

在这里我们可以看到此列表的两个级别都具有外部依赖关系，顶级导入脚本中的函数和来自 JSON 文件的数据，嵌套组件连接到 Vuex 存储并使用 axios 发布。它们还具有仅适用于其当前使用的嵌入式功能（顶级数据处理和嵌套列表的 onClick 功能）。

虽然这里采用了一些很好的通用设计技术，例如将通用的 munging 函数移动到外部脚本而不是嵌入硬编码数据，但这仍然不是非常可重用的。如果我们想要完全相同类型的列表，但是从 API 获取其数据会怎么样？或者在单击嵌套项时有不同的行为？我们根本无法将其复制/粘贴到一些新组件中并更改这些功能。

让我们看看我们是否可以通过提升数据并将事件处理作为 props 传递来解决这个问题，这样组件就可以简单地呈现数据而不会封装任何其他逻辑。

这是列表的新顶级：

![img](https://cdn-images-1.medium.com/max/1600/0*_OM8O-ONfOtk8mqP)

而新的第二级：

![img](https://cdn-images-1.medium.com/max/1600/0*Kx5vgTwEMt8FmBdz)

使用这个新列表，我们获得了我们想要的数据，并定义了嵌套的 onClick 处理程序，以便在父级中执行任何我们想要的操作，然后将它们作为 props 传递给顶级组件。这样，我们不需要在为新用例利用它们时复制任何组件，我们可以将导入和逻辑留给单个根组件。

有关此主题的简短文章可以在[这里](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)找到。它由 Redux 的共同创建者 Dan Abramov 编写，具体与 React 有关。但是，它适用于通用组件设计。

### 及时模块化

在尝试更加主动地将代码分解为松散耦合的，可重用的块是一件好事时，它当然有可能过火。并非每一点标记都需要成为它自己的组件，并不是每一点逻辑都需要被拉出到外部脚本。

在决定是否将代码分开时，无论是 Javascript 逻辑还是新组件，都需要考虑以下几点。同样，这个列表并不完整，只是为了让你了解需要考虑的各种事项。（记住，仅仅因为它不满足一个条件并不意味着它不会满足其他条件，所以在做出决定之前要考虑所有条件）：

1. **是否有足够的标记/逻辑来保证它？**如果它只是几行代码，那么最终可能会创建更多的代码来分隔它，而不仅仅是将代码放入其中。
2. **代码重复（或可能重复）？**如果某些东西只使用一次，并且服务于一个不太可能在其他地方使用的特定用例，那么将它嵌入其中可能会更好。如果需要，你可以随时将其分开（但不要以此为借口永远不要这样做）。
3. **它会减少你的样板吗？**例如，假设你想要一个用于样式的 div 树和一些静态内容/功能，其中一些可变内容嵌套在中心。通过创建可重用的包装器（与 React 的 HOC 或 Vue 的插槽一样），你可以在创建这些组件的多个实例时减少样板，因为你不需要复制/粘贴所有静态包装代码。
4. **你的表现难受吗？**更改状态/道具会导致重新渲染，当发生这种情况时，你只需要对相关元素进行衍射和重新渲染。在较大的，无差别的组件中，你可能会发现状态更改会导致在不需要它的许多地方重新呈现，并且你的性能可能会开始受损。
5. **你是否在测试代码的所有部分时遇到问题？**你希望能够测试各种各样的东西，比如那些组件无论其上下文如何都可以工作，并且所有 Javascript 逻辑都按预期工作。当元素具有单个假设的上下文或者分别将一大堆逻辑嵌入到单个函数中时，这可能很难。如果测试具有大量标记和样式的单个巨型组件，渲染测试也会变得难以处理。
6. **你有明确的理由吗？**在分割代码时，你应该考虑它究竟实现了什么。这是否允许更松散的耦合？我是否打破了一个逻辑上有意义的独立实体？这个代码是否真的可能在其他地方重复使用？如果你不能清楚地回答这个问题，那么你只是为了它而将代码分成（可能紧密耦合的）块，这可能会导致问题。
7. **这些好处是否超过了成本？**分离代码不可避免地需要时间和精力，其数量根据具体情况而变化，并且在最终做出此决定时会有许多因素（例如此列表中的点等等）。一般来说，对抽象的成本和收益进行一些研究可以帮助你了解在为代码做出此决定时要记住的一些因素。最后，我提到了这一点，因为如果我们过分关注优势，就很容易忘记所需的努力。权衡一切并做出明智的决定。

### 集中/共享的州住宿

许多大型应用程序使用 Redux 或 Vuex 等集中存储工具（或者具有 React 的 Context API 等状态共享设置）。这意味着他们从商店获得道具而不是通过父母传递。在考虑组件的可重用性时，你不仅要考虑直接的，父母的道具，还要考虑商店的道具。如果你在另一个项目中使用该组件，则需要在商店中使用这些值。或许其他项目根本不使用集中存储工具，你必须将其转换为现在作为父级道具传递的形式。

由于将组件挂接到商店（或上下文提供程序）很容易并且无论组件的层次结构位置如何都可以完成，因此很容易在商店和整个层次结构中的组件 Web 之间快速创建大量紧密耦合。通常将组件连接到商店只需几行，然后它为你附加的每个属性/功能添加一条额外的行。请记住，虽然这种耦合可能很容易，但它的含义并没有什么不同，你应该想办法减轻风险，就像你使用父母道具一样。

### 最后的想法

我想简要提醒一下这些原则的实际应用，或者你可能阅读的任何最佳实践。虽然你应该尽力维护良好的设计，不要为了包装 JIRA 票或关闭拉动请求而损害代码完整性，同时总是把理论置于现实世界结果之上的人也往往会让他们的工作受到影响。大型软件项目有许多活动部分，软件工程的许多方面与编码没有特别的关系，但仍然是不可或缺的，例如遵守最后期限和处理非技术期望。

虽然充分的准备很重要，应该成为任何专业软件设计的一部分，但在现实世界中，切实的结果是至关重要的。当你被雇用来实际创造一些东西时，如果在最后期限到来之前，你有一个如何完美地构建产品的惊人**计划**，没有实际的开发，你的雇主就不会太高兴。此外，软件工程中的东西很少完全按计划进行，因此过度具体的计划往往会在时间使用方面开始适得其反。

此外，组件规划和设计的概念也适用于组件重构。虽然用了 50 年的时间来计划一切令人难以忍受的细节，然后从一开始就完美地编写它就会很好，回到现实世界，当你的关键时刻到来时你可能会发现自己设计组件并以不太理想的方式编写代码。然而，一旦压力得到缓解并且你有时间，那么返回并重构早期没有理想构建的代码总是一个好主意，这样它就可以作为向前发展的坚实基础。

在一天结束时，虽然你的直接责任可能是“编写代码”，但你不应忽视你的最终目标，即建立一些东西。创建产品。为了产生一些你可以引以为豪的东西并帮助人们，即使它在技术上并不完美。因为什么都没有。永远记得找到一个平衡点。不幸的是，在一周内每天 8 小时盯着代码库不幸地催生了一个狭窄的，近视的项目视图，但是你需要在需要的时候退后一步，确保你不要错过森林对于树木。
