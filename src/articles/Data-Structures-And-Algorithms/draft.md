* 排序
  * 冒泡
  * 选择
    * 每次选出剩下的元素中的最值，放入有序部分的末端
    * 不稳定
    * n*n
  * 插入
    * 把无序部分的第一个数插入到有序部分相应位置
    * 有序部分顺序查找
    * 有序部分二分查找
    * 改为链表
      * 插入性能为1
      * 查找性能又降为n
    * 改为排序二叉树
      * 查找logn
      * 插入为1
      * 总共n个元素
      * n*logn
      * 稳定
      * 空间复杂度为n
  * 归并
    * 两个有序数组合并成一个
      * 总是选择当前两个数组首项中的最值，放入结果数组中
    * 无法就地排序
    * 需要n的额外空间
    * 稳定
    * 时间复杂度是n*logn
    * 扩展问题，n个有序数组，合并成一个
      * 
  * 堆排序
    * 堆是一种有序树
    * 树中的父结点总是比两个子结点大/小
    * 堆支持的两种操作
      * 去掉堆顶（树根）元素
        * 把堆尾的元素放入堆顶，从顶部开始调整
      * 向堆里增加新的元素
        * 每次增加到最后，从增加的元素位置开始调整
      * 无论哪种操作，都必须得在操作完成后保证堆的性质
    * 一般来说堆都是完全二叉树
      * 所以一般使用顺序存储的方式（数组）
    * 排序
      * 数组的前一部分是堆
      * 后一部分是有序序列
      * 每次把堆顶的元素放入有序部分的开头
      * 调整堆
    * 不稳定
    * 外排序
  * 快速排序
    * 把数组按照某个pivot元素一分为二
      * 小于pivot的元素放在左边
      * 大于等于的放在右边
      * 递归对左右两边的子数组继续执行快排
    * 两种写法：
      * 使用额外数组的
      * 就地调整的
    * 不稳定
    * 扩展：
      * 找出数组第k大的元素
      * 找出前k大的元素
        * 也可以使用堆
          * 如果不修改输入数据
            * 用堆会更好，因为只需要一k大的堆
  * 桶排序
    * 非比较排序
    * 只适用于纯数字的排序
  * 基数排序
  * 希尔排序
  * 计数排序
